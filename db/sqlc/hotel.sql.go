// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: hotel.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createHotel = `-- name: CreateHotel :one
INSERT INTO hotel (
  hotel_id,
  destination_id,
  type_id,
  total_room,
  rating
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING hotel_id, destination_id, type_id, total_room, rating
`

type CreateHotelParams struct {
	HotelID       uuid.UUID       `json:"hotel_id"`
	DestinationID uuid.NullUUID   `json:"destination_id"`
	TypeID        sql.NullString  `json:"type_id"`
	TotalRoom     sql.NullInt32   `json:"total_room"`
	Rating        sql.NullFloat64 `json:"rating"`
}

func (q *Queries) CreateHotel(ctx context.Context, arg CreateHotelParams) (Hotel, error) {
	row := q.queryRow(ctx, q.createHotelStmt, createHotel,
		arg.HotelID,
		arg.DestinationID,
		arg.TypeID,
		arg.TotalRoom,
		arg.Rating,
	)
	var i Hotel
	err := row.Scan(
		&i.HotelID,
		&i.DestinationID,
		&i.TypeID,
		&i.TotalRoom,
		&i.Rating,
	)
	return i, err
}

const deleteHotel = `-- name: DeleteHotel :exec
DELETE FROM hotel
WHERE hotel_id = $1
`

func (q *Queries) DeleteHotel(ctx context.Context, hotelID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteHotelStmt, deleteHotel, hotelID)
	return err
}

const getHotel = `-- name: GetHotel :one
SELECT hotel_id, destination_id, type_id, total_room, rating FROM hotel
WHERE hotel_id = $1 LIMIT 1
`

func (q *Queries) GetHotel(ctx context.Context, hotelID uuid.UUID) (Hotel, error) {
	row := q.queryRow(ctx, q.getHotelStmt, getHotel, hotelID)
	var i Hotel
	err := row.Scan(
		&i.HotelID,
		&i.DestinationID,
		&i.TypeID,
		&i.TotalRoom,
		&i.Rating,
	)
	return i, err
}

const listHotels = `-- name: ListHotels :many
SELECT hotel_id, destination_id, type_id, total_room, rating FROM hotel
ORDER BY hotel_id
LIMIT $1
OFFSET $2
`

type ListHotelsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListHotels(ctx context.Context, arg ListHotelsParams) ([]Hotel, error) {
	rows, err := q.query(ctx, q.listHotelsStmt, listHotels, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Hotel{}
	for rows.Next() {
		var i Hotel
		if err := rows.Scan(
			&i.HotelID,
			&i.DestinationID,
			&i.TypeID,
			&i.TotalRoom,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHotelsByDestination = `-- name: ListHotelsByDestination :many
SELECT hotel_id, destination_id, type_id, total_room, rating FROM hotel
WHERE destination_id = $1
ORDER BY rating DESC
LIMIT $2
OFFSET $3
`

type ListHotelsByDestinationParams struct {
	DestinationID uuid.NullUUID `json:"destination_id"`
	Limit         int32         `json:"limit"`
	Offset        int32         `json:"offset"`
}

func (q *Queries) ListHotelsByDestination(ctx context.Context, arg ListHotelsByDestinationParams) ([]Hotel, error) {
	rows, err := q.query(ctx, q.listHotelsByDestinationStmt, listHotelsByDestination, arg.DestinationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Hotel{}
	for rows.Next() {
		var i Hotel
		if err := rows.Scan(
			&i.HotelID,
			&i.DestinationID,
			&i.TypeID,
			&i.TotalRoom,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateHotel = `-- name: UpdateHotel :one
UPDATE hotel
SET 
  destination_id = $2,
  type_id = $3,
  total_room = $4,
  rating = $5
WHERE hotel_id = $1
RETURNING hotel_id, destination_id, type_id, total_room, rating
`

type UpdateHotelParams struct {
	HotelID       uuid.UUID       `json:"hotel_id"`
	DestinationID uuid.NullUUID   `json:"destination_id"`
	TypeID        sql.NullString  `json:"type_id"`
	TotalRoom     sql.NullInt32   `json:"total_room"`
	Rating        sql.NullFloat64 `json:"rating"`
}

func (q *Queries) UpdateHotel(ctx context.Context, arg UpdateHotelParams) (Hotel, error) {
	row := q.queryRow(ctx, q.updateHotelStmt, updateHotel,
		arg.HotelID,
		arg.DestinationID,
		arg.TypeID,
		arg.TotalRoom,
		arg.Rating,
	)
	var i Hotel
	err := row.Scan(
		&i.HotelID,
		&i.DestinationID,
		&i.TypeID,
		&i.TotalRoom,
		&i.Rating,
	)
	return i, err
}
