// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: room.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createRoom = `-- name: CreateRoom :one
INSERT INTO room (
  room_id,
  room_name,
  hotel_id,
  floor,
  type_id,
  max_capacity,
  rate,
  description,
  price,
  created_at,
  created_by,
  update_at,
  update_by
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING room_id, room_name, hotel_id, floor, type_id, max_capacity, rate, description, price, created_at, created_by, update_at, update_by
`

type CreateRoomParams struct {
	RoomID      uuid.UUID       `json:"room_id"`
	RoomName    sql.NullString  `json:"room_name"`
	HotelID     uuid.NullUUID   `json:"hotel_id"`
	Floor       sql.NullInt32   `json:"floor"`
	TypeID      sql.NullString  `json:"type_id"`
	MaxCapacity sql.NullInt32   `json:"max_capacity"`
	Rate        sql.NullFloat64 `json:"rate"`
	Description sql.NullString  `json:"description"`
	Price       sql.NullInt32   `json:"price"`
	CreatedAt   sql.NullTime    `json:"created_at"`
	CreatedBy   uuid.NullUUID   `json:"created_by"`
	UpdateAt    sql.NullTime    `json:"update_at"`
	UpdateBy    uuid.NullUUID   `json:"update_by"`
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (Room, error) {
	row := q.queryRow(ctx, q.createRoomStmt, createRoom,
		arg.RoomID,
		arg.RoomName,
		arg.HotelID,
		arg.Floor,
		arg.TypeID,
		arg.MaxCapacity,
		arg.Rate,
		arg.Description,
		arg.Price,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.UpdateAt,
		arg.UpdateBy,
	)
	var i Room
	err := row.Scan(
		&i.RoomID,
		&i.RoomName,
		&i.HotelID,
		&i.Floor,
		&i.TypeID,
		&i.MaxCapacity,
		&i.Rate,
		&i.Description,
		&i.Price,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdateAt,
		&i.UpdateBy,
	)
	return i, err
}

const deleteRoom = `-- name: DeleteRoom :exec
DELETE FROM room
WHERE room_id = $1
`

func (q *Queries) DeleteRoom(ctx context.Context, roomID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteRoomStmt, deleteRoom, roomID)
	return err
}

const getAvailableRooms = `-- name: GetAvailableRooms :many
SELECT r.room_id, r.room_name, r.hotel_id, r.floor, r.type_id, r.max_capacity, r.rate, r.description, r.price, r.created_at, r.created_by, r.update_at, r.update_by FROM room r
WHERE r.hotel_id = $1
  AND r.room_id NOT IN (
    SELECT res.room_id FROM reservation res
    WHERE res.room_id = r.room_id
      AND res.status = 'confirmed'
      AND (
        (res.start_date <= $2 AND res.end_date > $2) OR
        (res.start_date < $3 AND res.end_date >= $3) OR
        (res.start_date >= $2 AND res.end_date <= $3)
      )
  )
ORDER BY r.price
LIMIT $4
OFFSET $5
`

type GetAvailableRoomsParams struct {
	HotelID     uuid.NullUUID `json:"hotel_id"`
	StartDate   sql.NullTime  `json:"start_date"`
	StartDate_2 sql.NullTime  `json:"start_date_2"`
	Limit       int32         `json:"limit"`
	Offset      int32         `json:"offset"`
}

func (q *Queries) GetAvailableRooms(ctx context.Context, arg GetAvailableRoomsParams) ([]Room, error) {
	rows, err := q.query(ctx, q.getAvailableRoomsStmt, getAvailableRooms,
		arg.HotelID,
		arg.StartDate,
		arg.StartDate_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Room{}
	for rows.Next() {
		var i Room
		if err := rows.Scan(
			&i.RoomID,
			&i.RoomName,
			&i.HotelID,
			&i.Floor,
			&i.TypeID,
			&i.MaxCapacity,
			&i.Rate,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdateAt,
			&i.UpdateBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoom = `-- name: GetRoom :one
SELECT room_id, room_name, hotel_id, floor, type_id, max_capacity, rate, description, price, created_at, created_by, update_at, update_by FROM room
WHERE room_id = $1 LIMIT 1
`

func (q *Queries) GetRoom(ctx context.Context, roomID uuid.UUID) (Room, error) {
	row := q.queryRow(ctx, q.getRoomStmt, getRoom, roomID)
	var i Room
	err := row.Scan(
		&i.RoomID,
		&i.RoomName,
		&i.HotelID,
		&i.Floor,
		&i.TypeID,
		&i.MaxCapacity,
		&i.Rate,
		&i.Description,
		&i.Price,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdateAt,
		&i.UpdateBy,
	)
	return i, err
}

const listRooms = `-- name: ListRooms :many
SELECT room_id, room_name, hotel_id, floor, type_id, max_capacity, rate, description, price, created_at, created_by, update_at, update_by FROM room
ORDER BY room_id
LIMIT $1
OFFSET $2
`

type ListRoomsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListRooms(ctx context.Context, arg ListRoomsParams) ([]Room, error) {
	rows, err := q.query(ctx, q.listRoomsStmt, listRooms, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Room{}
	for rows.Next() {
		var i Room
		if err := rows.Scan(
			&i.RoomID,
			&i.RoomName,
			&i.HotelID,
			&i.Floor,
			&i.TypeID,
			&i.MaxCapacity,
			&i.Rate,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdateAt,
			&i.UpdateBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoomsByHotel = `-- name: ListRoomsByHotel :many
SELECT room_id, room_name, hotel_id, floor, type_id, max_capacity, rate, description, price, created_at, created_by, update_at, update_by FROM room
WHERE hotel_id = $1
ORDER BY floor, room_name
LIMIT $2
OFFSET $3
`

type ListRoomsByHotelParams struct {
	HotelID uuid.NullUUID `json:"hotel_id"`
	Limit   int32         `json:"limit"`
	Offset  int32         `json:"offset"`
}

func (q *Queries) ListRoomsByHotel(ctx context.Context, arg ListRoomsByHotelParams) ([]Room, error) {
	rows, err := q.query(ctx, q.listRoomsByHotelStmt, listRoomsByHotel, arg.HotelID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Room{}
	for rows.Next() {
		var i Room
		if err := rows.Scan(
			&i.RoomID,
			&i.RoomName,
			&i.HotelID,
			&i.Floor,
			&i.TypeID,
			&i.MaxCapacity,
			&i.Rate,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdateAt,
			&i.UpdateBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoom = `-- name: UpdateRoom :one
UPDATE room
SET 
  room_name = $2,
  hotel_id = $3,
  floor = $4,
  type_id = $5,
  max_capacity = $6,
  rate = $7,
  description = $8,
  price = $9,
  update_at = $10,
  update_by = $11
WHERE room_id = $1
RETURNING room_id, room_name, hotel_id, floor, type_id, max_capacity, rate, description, price, created_at, created_by, update_at, update_by
`

type UpdateRoomParams struct {
	RoomID      uuid.UUID       `json:"room_id"`
	RoomName    sql.NullString  `json:"room_name"`
	HotelID     uuid.NullUUID   `json:"hotel_id"`
	Floor       sql.NullInt32   `json:"floor"`
	TypeID      sql.NullString  `json:"type_id"`
	MaxCapacity sql.NullInt32   `json:"max_capacity"`
	Rate        sql.NullFloat64 `json:"rate"`
	Description sql.NullString  `json:"description"`
	Price       sql.NullInt32   `json:"price"`
	UpdateAt    sql.NullTime    `json:"update_at"`
	UpdateBy    uuid.NullUUID   `json:"update_by"`
}

func (q *Queries) UpdateRoom(ctx context.Context, arg UpdateRoomParams) (Room, error) {
	row := q.queryRow(ctx, q.updateRoomStmt, updateRoom,
		arg.RoomID,
		arg.RoomName,
		arg.HotelID,
		arg.Floor,
		arg.TypeID,
		arg.MaxCapacity,
		arg.Rate,
		arg.Description,
		arg.Price,
		arg.UpdateAt,
		arg.UpdateBy,
	)
	var i Room
	err := row.Scan(
		&i.RoomID,
		&i.RoomName,
		&i.HotelID,
		&i.Floor,
		&i.TypeID,
		&i.MaxCapacity,
		&i.Rate,
		&i.Description,
		&i.Price,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdateAt,
		&i.UpdateBy,
	)
	return i, err
}
